Чтобы понять что такое объектно-ориентированное программирование (ООП), для начала разберемся что же подразумевается под понятием объект.

Оглянись вокруг себя, посмотри на вещи которые тебя окружают (стихия, предметы, люди, животные, растения и тд и тп). Всё, за что может зацепиться твой взгляд - в программировании является объектом. Другими словами, объект в ООП - это програмная модель чего либо, это некая сущность, служащая контейнером для данных и методов управления этими данными.
В программировании объекты это экземпляры класса (class). Класс это своего рода чертеж/ДНК, а объект уже готовая сущность выращенная из этого ДНК или построенная по чертежу. То есть, для того чтобы манипулировать объектом, - сперва нужно создать класс этого объекта.
В листинге 6.1 приведен синтаксис создания класса в Ruby. Важно знать что имена классов следует записывать с большой буквы.
#Листинг 6.1
class MyClass
    
end

ООП это фундамент 3х этажного здания, этажами которого являются инкапсуляция, наследование и полиморфизм.

1. Инкапсуляция
Инкапсуляция - это принцип сокрытия информации, путем управления областью видимости атрибутов и методов класса.
Возьмем к примеру ноутбук. Ты понятия не имеешь как там всё внутри работает. Тебе доступны только возможности клацать по клавиатуре, пялится в экран, шевелить мышкой, включать/выключать его. О том что происходит внутри компьютера после нажатия той или иной кнопки - ты не задумываешься. Потому что все эти процессы от тебя инкапсулированны и как результат - ты не можешь воздейтвовать на внутренние процессы ноутбука.
Вернемся к программированию. Создадим класс человека см. листинг 6.2.
# Листинг 6.2
class Human #создаем класс, присваиваем ему имя Human
    attr_accessor :name, :age # аксессоры

    def initialize (name, age) # конструктор класса.
        @name = name # переменная объекта
        @age = age
    end
end

qpi = Human.new('Qpi', 32) # создаем объект qpi
puts "Меня зовут #{qpi.name} и я родился #{qpi.age} года назад "

Сделаю небольшое отступление и разберу синтаксис листинга 6.2
Переменные в Ruby пишутся нижним регистром (маленькими буквами). Существует несколько видов переменных:

var - локальная переменная, область видимости которой не выходит за пределы блоков/методов где она была определена

$var - глобальная переменная, область видимости - "везде"

@var - переменная экземпляра класса (объекта). Область видимости весь класс.

@@var - переменная класса. Область видимости - весь класс + все экземпляры класса (все объекты).

Const - константа. Пишется всегда с заглавной буквы. Область видимости - "везде". Во многих ЯП (языках программировани) значение константы переопределить нельзя, и это логично. В руби же, менять значение константы можно, зачем - я не вкурсе.

В программирование есть такие понятия как геттеры и сеттеры, от англ get (взять) и set (установить/присвоить). Это методы, с помощью которых объект может читать или изменять переменные (атрибуты) класса. В Ruby  геттеры и сеттеры объявляются следующим образом
# Листинг 6.3
def name
    @name
end
def name=(name)
    @name=name
end

Но такая запись довольно-таки громоздкая не правда ли? Представь если нам нужно будет сделать много таких геттеров и сеттеров, сколько строк  будет дублироваться и переполнять пространство в листинге кода? Руби бы не был руби, если бы не давал красивого, короткого и понятного синтаксиса - у него есть аксессоры аттрибутов (переменных).
Аксессоры бывают 3х типов, 
аксессор только на чтение - attr_reader,
акессеор только на изменение/запись attr_writer
аксессор на чтение и изменение attr_accessor. 

В листинге 6.2 имеется строка
attr_accessor :name, :age # аксессоры

Объявлен аксессор на чтение и изменение атрибутов, перечисленных через запятую.
Атрибуты объявляются как символы (см. на двоеточие перед именем атрибута), о них мы поговорим позже.
Следующий интересный момент листинга 6.2 - это конструктор класса
 def initialize (name, age) # конструктор класса.
        @name = name # переменная объекта
        @age = age
 end

Конструктор класса - это метод, который выполняется в момент создания экземпляра класса.
Конструктор является приватным методом класса, и любая попытка обратиться к нему напрямую вызовет исключение NoMethodError
В последних двух строках листинга 6.2 мы определяем экземпляр класса (qpi), и делаем распечатку имени и возраста нашего страдальца.
Вернемся к инкапсуляции.
У нас есть человек, которого зовут Qpi и ему 32 года. Давайте представим себе, что нашему человеку приспичило поменять свой возраст. Для этого достаточно написать
qpi.age = 24 # обращаемся напрямую к атрибуту age и меняем возраст пациента
puts qpi.age # выведет 24

Что за магия черт возьми?) 
Я не могу просто так взять и поменять себе возраст, темболее в меньшую сторону. Для того чтобы это сделать, разве я не должен выпить элексир молодости? или дать взятку в паспортном столе чтобы мне выдали новый пасспорт с нужной мне датой рождения?.
Вывод - здесь кроется логическая ошибка, которая в реальной программе, при неправильном использовании класса, может вызвать фатальную катастрофу. Так как же быть? да ты и сам догадался,
- нужно инкапсулировать атрибут возраста, чтобы объект не мог его менять напрямую, а если приспичит, создать в классе метод, который будет это делать. А сделать он это сможет при соблюдении определенных условий (наличие элексира молодости, или взятки в паспортный стол).
# Листинг 6.4
class Human
    attr_reader :name, :age

    def initialize (name, age)
        @name = name
        @age = age
    end

    def change_age_to(new_age)
        @age = new_age if check_conditions
    end

    def check_conditions
        # проверяем выполнены ли какието особые требования для смены возраста.
        true # типа проверили и возвращаем true (истина)
    end
end

qpi = Human.new('Qpi', 32) # создаем объект qpi
puts "Меня зовут #{qpi.name} и я родился #{qpi.age} года назад "

#qpi.age=24 # => 6.4.rb:23:in `<main>': undefined method `age=' for #<Human:0x000000028db358 @name="Qpi", @age=32> (NoMethodError)

qpi.change_age_to 24
puts "Меня зовут #{qpi.name} и я родился #{qpi.age} года назад " # => Меня зовут Qpi и я родился 24 года назад 

Суть инкапсуляции вкурил? вкурил.. Я рассказал про инкапсуляцию атрибутов класса, осталось рассказать про инкапсуляцию методов класса.

Инкапсуляция методов класса существует по вышеуказанным причинам.
Управляя своим авто, нам доступны 3 (или 2) педали, коробка передач, рулевое управление ну и по мелочам там поворотники, подогрев сидений и тд.
Нажимая на педаль тормоза, машина тормозит, нажимая на газ - едит, а как это происходит уже дело десятое, нам главное результат верно?
Объекту - да, ему плевать с большой колокольни. А тебе как инженеру проектировщику (классу) далеко не всё равно, тебе нужно чтобы объект не совал свой нос туда куда не следует, и не поломал в результате авто.
Как ты наверное понял, методы класса - это блоки кода. которые выполняют те или иные операции. Если объект вызывает метод "тормозить", этот метод начинает вызывать уже инкапсулированные методы, которые объекту не доступны, такие как сбор информации (скорость, давление в шинах и тд), определяет силу давления на "педаль тормоза" и так далее и зажимает уже тормозными колодками тормозные диски каждого колеса отдельно с определенной (вычесленной) силой. Все это выполняется четко продуманно и последовательно, не расчитывая на то что в процесс торможения может влезть "тупой" юзер, и всё перевернуть с ног наголову. А что бы было если бы ты мог влезть в этот процесс? и начал вызывать все методы класса необходимые для торможения в неправильном порядке или передавал им неверные данные? Была бы авария..
Как я уже говорил, инкапсуляция подразумевает собою управление областью видимости атрибутов и методов класса. Методы имеют несколько разновидностей инкапсуляции:

public - Область видимости в пределах класса, экземпляра класса и всех потомков класса (про потомки мы поговорим ниже, это 2й этаж 3х этажного здания ООП)

protected - Область видимости внутри класса и всех его потомков

private - Область видимости внутри класса

Синтаксис инкапсуляции методов следующий:
# Листинг 6.5
class MyClass

    def method_one #По умолчанию все методы публичные
        # .......
    end

    protected  #или private, или public. Так метод method_two, и ВСЕ МЕТОДЫ НИЖЕ инкапсулируются указанной здесь областью видимости
    def method_two # т.е. не имеет значения какую область видимости мы указали, её наследуют все методы прописанные ниже, если не указана область явно.
        # .......
    end

    def method_three # область видимости будет такая же, как в method_two
        # .......
    end

    def method_four
        # .......
    end

    def method_five
        # .......
    end

    def method_six
        # .......
    end

    private :method_four, :method_five #иной способ инкапсуляции методов класса. Указываем тип инкапсуляции и методы в виде символов через запятую
    protected :method_six

end

2. Наследование
Наследование - 2й этаж 3х этажного здания.  Пожалуй самый яркий пример наследования в реальной жизни - это эволюция. Все что есть вокруг нас произошло от чегото более простого.  По теории Дарвина, человек унаследован от обезьяны. Т.е. грубо говоря - человек апгрейченная обезьяна, - меньше волос, чуток больше мозгов, чуть иная анатомия и тд. Точно по такому же принципу в ООП происходит наследование классов.
Для примера возьмем табурет и кресло. И на том и на том можно сидеть. Но между двумя этими предметами есть небольшая (очевидная) разница. И табурет и кресло имеет свои характеристики, и может выполнять определенные функции.

# Листинг 6.6
class Stool # объявляем класс, даем ему имя Stool (табуретка)
    attr_reader :weight, :max_weight, :height, :material # геттеры

    def initialize(weight=5, max_weight=100,  height=0.5, material='wood') #конструктор класса
        #Присваиваем значения переменным (атрибутам) класса
        @weight = weight
        @max_weight = max_weight
        @height = height
        @material = material
    end

    def action_seat # на табурете можно сидеть
        # делаем чтото..
    end

    def action_stand # на табурете можно стоять
        # делаем чтото..
    end
end

class Armchair
    attr_reader :weight, :max_weight, :height, :height_range, :material

    def initialize(weight=15, max_weight=200,  height=0.5, height_range=0.3, material='leather')
        @weight = weight
        @max_weight = max_weight
        @height = height
        @material = material
        @height_range = height_range #доступный диапозон регулировки высоты
    end

    def action_height_adjustment #регулировка высоты кресла 
        # делаем чтото..
    end

    def action_seat # можно сидеть
        # делаем чтото..
    end

    def action_stand # можно стоять, хоть и с риском навернуться
        # делаем чтото..
    end
end


Ты наверняка обратил внимание что у двух этих классов присутствуют одинаковые методы и атрибуты, и как итог - дублирование кода, что противоречит философии Руби. Давай попробуем унаследовать один класс от другого. Кресло будет потомком табурета
# Листинг 6.7
class Stool
    attr_reader :weight, :max_weight, :height, :material

    def initialize(weight=5, max_weight=100,  height=0.5, material='wood')
        @weight = weight
        @max_weight = max_weight
        @height = height  #подразумевается высота от пола до задницы
        @material = material
    end

    def action_seat
        # делаем чтото..
    end

    def action_stand
        # делаем чтото..
    end
end

class Armchair < Stool # Запись вида ClassName1 < ClassName2 говорит о том, что ClassName1 является потомком класса ClassName2
    def initialize(weight=15, max_weight=200,  height=0.5, height_range=0.3, material='leather') #наследственный полиморфизм (3й этаж)
        super(weight, max_weight, height, material) 
        @height_range = height_range #доступный диапозон регулировки высоты
    end

    def action_height_adjustment #регулировка высоты
        # делаем чтото..
    end
end

В листинге 6.7 видно что класс Armchair унаследован от класса Stool, таким образом класс Armchair получил в свое распоряжение все атрибуты классa Stool, и все public и protected методы.
Каждый отдельный класс может быть потомком только одного класса, т.е. множественного наследования нет, иначе бы появилась проблема конфликтов имён. Зато у руби есть модули, которые позволяют создавать примеси в классах. О модулях мы поговорим чуть позже.

3. Полиморфизм
Ну вот поднялись мы и на 3й этаж ООП здания.
Полиморфизм (поли — много, морфе — форма) буквально означает "способность принимать разные формы и обличия".
Существует наследственный полиморфизм и интерфейсный полиморфизм.
Наследственный полиморфизм мы использовали в листинге 6.7 в классе Armchar, когда переопределили метод initialize, а реализация интерфейсного полиморфизма у руби в виде модулей, про которые я уже упоминал.
Наследственный полиморфизм используется в классе-потомке и позволяет переопределить унаследованные атрибуты и методы класса-родителя. 
В листинге 6.7 мы переопределили,  метод initialize дополнив его атрибутом @height_range а также мы использовали выражение super() для того чтобы выполнить родительский одноименный метод, в данном случае это конструктор класса.
Если бы мы не вызывали родительский одноименный метод, то конструктор родительского класса бы не выполнился.
Иными словами super() нужен для дополнения "устаревших" версий методов класса-родителя, при  переопределении оных классом потомком. 
Вот и всё, ничего сложного. В следующей главе, мы поговорим о модулях и метапрограммировании.
